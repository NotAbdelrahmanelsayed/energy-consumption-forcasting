import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler

def read_data(data_path):
    # Read the dataset
    df = pd.read_csv(data_path)

    # Rename features for consistency
    renamed_features = {
        'Date ': 'date',
        'Ambient Temperature': 'ambient_temperature',
        'wind_speed_10m (km/h)': 'wind_speed_10m_kmh',
        'wind_speed_100m (km/h)': 'wind_speed_100m_kmh',
        'Solar Radiation': 'solar_radiation'
    }
    df.rename(columns=renamed_features, inplace=True)

    # Drop rows with missing values
    df.dropna(axis=0, inplace=True)

    # Convert date to datetime and set it as the index
    df['date'] = pd.to_datetime(df['date'])
    df.set_index('date', inplace=True)

    # Convert the dataset into numpy array
    data = np.array(df)
    # Scale the dataset
    scaler = MinMaxScaler()
    data = scaler.fit_transform(data)
    return data, scaler, df.index

def create_sequences(data, sequence_length):
    X = []
    for i in range(len(data) - sequence_length):
        X.append(data[i:i+sequence_length])
    return np.array(X)

def generate_future_predictions(model, initial_sequence, num_predictions):
    predictions = []
    current_sequence = initial_sequence

    for _ in range(num_predictions):
        prediction = model.predict(current_sequence[np.newaxis, :, :])
        predictions.append(prediction.flatten())
        current_sequence = np.append(current_sequence[1:], prediction, axis=0)
    
    return np.array(predictions)

def generate_future_dates(last_date, num_days):
    return pd.date_range(start=last_date, periods=num_days + 1, inclusive='right')


def plot_historical_and_predicted_data(df_combined, num_predictions):
    """
    Plots historical and predicted data for the last four years and forecasted data.

    Parameters:
    - df_combined: DataFrame containing combined historical and predicted data.
    - num_predictions: Number of prediction points (hours) generated by the model.
    """
    # Calculate the focus start date for the last four years
    focus_start_date = df_combined.index[-(num_predictions + 3 * 365 * 24)]

    # Slice the DataFrame to focus on the last four years and forecasted data
    df_focus = df_combined[focus_start_date:]

    # Ensure plotting within Jupyter Notebook
    %matplotlib inline

    # Use seaborn style
    sns.set(style='darkgrid')

    # Plot settings
    fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(15, 10))
    fig.suptitle('Historical and Predicted Data', fontsize=16)

    # Plot each feature
    features = ['Temperature', 'Wind Speed 10m', 'Wind Speed 100m', 'Solar Radiation']
    colors = ['#17becf', '#2ca02c']  # Colors for historical and predicted data

    for ax, feature in zip(axes.flatten(), features):
        # Plot historical data
        ax.plot(df_focus.index[:len(df_focus) - num_predictions], df_focus[feature][:len(df_focus) - num_predictions], color=colors[0], label='Historical data')

        # Plot predicted data
        predicted_start_idx = len(df_focus) - num_predictions
        ax.plot(df_focus.index[predicted_start_idx:], df_focus[feature][predicted_start_idx:], color=colors[1], label='Predicted data')

        # Highlight the transition point with a vertical line
        ax.axvline(x=df_focus.index[predicted_start_idx], color='black', linestyle='--')

        # Set the title and labels
        ax.set_title(feature)
        ax.set_xlabel('Time (h)')
        ax.set_ylabel(feature)

        # Add a legend
        ax.legend()
    # Adjust layout and show the plot
    plt.tight_layout(rect=[0, 0, 1, 0.96])
    plt.show()

# Function to make further predictions
def make_further_predictions(saved_predictions_path, model, scaler, sequence_length, num_further_predictions):
    # Load the saved predictions
    saved_predictions_df = pd.read_csv(saved_predictions_path, parse_dates=['Date'], index_col='Date')
    column_names = ['Temperature', 'Wind Speed 10m', 'Wind Speed 100m', 'Solar Radiation']

    # Process the saved predictions
    saved_predictions_data = saved_predictions_df[column_names].values
    scaled_saved_predictions = scaler.transform(saved_predictions_data)
    
    # Use the last sequence_length data points from the saved predictions to generate further predictions
    initial_sequence_from_predictions = scaled_saved_predictions[-sequence_length:]
    
    # Generate further predictions for the next month
    further_predictions = generate_future_predictions(model, initial_sequence_from_predictions, num_further_predictions)
    further_predictions = scaler.inverse_transform(further_predictions)
    further_predictions = np.clip(further_predictions, a_min=0, a_max=None)
    
    # Generate future dates for further predictions
    last_date_from_predictions = saved_predictions_df.index[-1]
    further_future_dates = pd.date_range(start=last_date_from_predictions, periods=num_further_predictions, freq='H')
    
    # Combine saved predictions and further predicted data
    all_dates_further = np.concatenate([saved_predictions_df.index, further_future_dates])
    combined_data_further = np.concatenate([saved_predictions_data, further_predictions])
    
    # Create DataFrame for combined data with further predictions
    df_combined_further = pd.DataFrame(
        combined_data_further,
        columns=column_names,
        index=all_dates_further
    )
    
    # Save the new predictions with dates including further predictions
    df_combined_further.reset_index(inplace=True)
    df_combined_further.rename(columns={'index': 'Date'}, inplace=True)
    df_combined_further.to_csv(saved_predictions_path, index=False)
    
    return df_combined_further
